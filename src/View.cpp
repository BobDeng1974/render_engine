#include <cassert>
#include "gl_headers.h"
#include "TextureManager.h"
#include "ShaderManager.h"
#include "Rectangle.h"
#include "VertexGroup.h"
#include "View.h"
#include "Scene.h"
#include "Model.h"
#include "Renderer.h"
#include "GLUniform.h"
#include "Camera.h"
#include "Interface.h"
#include "Element.h"

//
View::View(Vec2f window_size, Renderer *renderer) :
    renderer(renderer),
    window_size(window_size),
    drawable_screen_region(Vec2f(0, 0), window_size),
    projection(glm::perspective(45.0f, window_size.x / window_size.y, .1f, 20.0f)) {

    // bind the screen region quad to a draw buffer (for drawing the texture generated by the deferred renderers final pass)
    drawable_screen_region.add_gl_attribute(gl::Attribute(0, 2, GL_FLOAT, false, get_rectangle_vertex_data(drawable_screen_region)));
    drawable_screen_region.add_gl_attribute(gl::Attribute(1, 2, GL_FLOAT, false, get_rectangle_uv_data(drawable_screen_region)));
    for (auto &attribute : drawable_screen_region.get_gl_attributes()) {
        renderer->bind(attribute, STATIC);
    }
}

//
void View::prepare(Interface *interface) {
    while (interface->has_unprepared_elements()) {
        Element *element = interface->next_unprepared_element();
        // add the attributes
        element->add_gl_attribute(gl::Attribute(0, 2, GL_FLOAT, false, get_rectangle_vertex_data(element->get_bounds())));
        element->add_gl_attribute(gl::Attribute(1, 2, GL_FLOAT, false, get_rectangle_uv_data(element->get_bounds())));

        // bind the attributes
        for (auto &attribute : element->get_gl_attributes()) {
            renderer->bind(attribute, STATIC);
        }
    }
}

//
void View::render(Interface *interface) {
    // prepare new elements
    prepare(interface);
    // disable depth support
    renderer->disable(GL_DEPTH_TEST);

    // draw elements
    for (auto *element : interface->get_elements()) {
        render(element);
    }
}

//
void View::prepare(Model *model) {
    // add the attributes
    model->add_gl_attribute(gl::Attribute(0, 3, GL_FLOAT, false, get_vector_data(model->get_vertices())));
    model->add_gl_attribute(gl::Attribute(1, 3, GL_FLOAT, false, get_vector_data(model->get_normals())));
    model->add_gl_attribute(gl::Attribute(2, 2, GL_FLOAT, false, get_vector_data(model->get_uvs())));

    // bind the model's attributes to buffers
    for (auto &attribute : model->get_gl_attributes()) {
        renderer->bind(attribute, STATIC);
    }

    // bind the vertex groups
    for (VertexGroup &vertex_group : model->get_vertex_groups()) {
        // bind the element indices into a buffer
        renderer->bind(vertex_group, STREAM, ELEMENT);
    }
}

//
void View::prepare(Scene *scene) {
    while (scene->has_unprepared_models()) {
        Model *model = scene->next_unprepared_model();
        prepare(model);
    }
    while (scene->has_unprepared_lights()) {
        Light *light = scene->next_unprepared_light();
        prepare(light);
    }
}

//
void View::prepare(Light *light) {
    // add the attributes
    light->add_gl_attribute(gl::Attribute(0, 3, GL_FLOAT, false, get_box_vertex_data(*light)));
    light->add_gl_attribute(gl::Attribute(1, 2, GL_FLOAT, false, get_box_uv_data(*light)));

    // bind the model's attributes to buffers
    for (auto &attribute : light->get_gl_attributes()) {
        renderer->bind(attribute, STATIC);
    }
}

//
void View::render(Light *light, const Camera *camera, std::vector<gl::Uniform> additional_uniforms) {
    std::vector<gl::Uniform> uniforms = additional_uniforms;
    // screen size uniform
    uniforms.push_back(gl::UniformVec2f(Shader::SCREEN_SIZE, &window_size));

    // camera position uniform
    Vec3f camera_position = camera->get_position();
    uniforms.push_back(gl::UniformVec3f(Shader::CAMERA_POSITION, &camera_position));

    // mvp uniform
    glm::mat4 mvp = this->projection * camera->get_view() * light->get_transform();
    uniforms.push_back(gl::UniformMatrix4f(Shader::MVP, false, &mvp));

    // light uniforms
    Vec3f light_position = light->get_position();
    Vec3f light_color = light->get_color();
    float light_radius = light->get_size().x;
    float light_intensity = light->get_intensity();
    uniforms.push_back(gl::UniformVec3f(Shader::LIGHT_POSITION, &light_position));
    uniforms.push_back(gl::UniformVec3f(Shader::LIGHT_COLOR, &light_color));
    uniforms.push_back(gl::Uniform1f(Shader::LIGHT_RADIUS, &light_radius));
    uniforms.push_back(gl::Uniform1f(Shader::LIGHT_INTENSITY, &light_intensity));

    // final pass
    renderer->draw(*light,
                   0, 36,
                   ShaderManager::get_instance()->get_shader("mrt_lighting.vert", "mrt_lighting.frag"),
                   uniforms);
}
void View::render(DrawableRectangle &rectangle, Shader *shader, std::vector<gl::Uniform> uniforms) {
    renderer->draw(rectangle, 0, 6, shader, uniforms);
}

//
void View::render(Scene *scene) {
    // prepare new models
    prepare(scene);

    // set renderer for mrt drawing (3 output textures: colors (diffuse), normals, depth)
    renderer->attach_render_targets(3);

    // geometry pass
    for (auto *model : scene->get_models()) {
        render(model, scene->get_camera());
    }

    // get the textures created from the mrt draw calls
    std::vector<Texture *> geometry_pass = renderer->clear_render_targets();

    // set renderer for mrt drawing (lighting textures: specular and emissive)
    renderer->attach_render_targets(2);

    // create uniforms for lighting pass out of the geometry pass textures
    std::vector<gl::Uniform> lighting_uniforms = {
        gl::UniformTexture(Shader::NORMAL_TEXTURE, geometry_pass[1]),
        gl::UniformTexture(Shader::POSITION_TEXTURE, geometry_pass[2])
    };

    // lighting pass
    for (auto *light : scene->get_lights()) {
        render(light, scene->get_camera(), lighting_uniforms);
    }

    // get the textures created from the lighting mrt draw calls
    std::vector<Texture *> lighting_pass = renderer->clear_render_targets();

    // top left viewport (diffuse)
    glViewport(0, window_size.y / 2, window_size.x / 2, window_size.y / 2);
    std::vector<gl::Uniform> diffuse_uniforms = {gl::UniformTexture(Shader::TEXTURE, geometry_pass[0])};
    this->render(drawable_screen_region,
                 ShaderManager::get_instance()->get_shader("simple_2d.vert", "simple_2d.frag"),
                 diffuse_uniforms);

    // top right viewport (world positions)
    glViewport(window_size.x / 2, window_size.y / 2, window_size.x / 2, window_size.y / 2);
    std::vector<gl::Uniform> normal_uniforms;
    normal_uniforms.push_back(gl::UniformTexture(Shader::TEXTURE, geometry_pass[2]));
    this->render(drawable_screen_region,
                 ShaderManager::get_instance()->get_shader("world_positions.vert", "world_positions.frag"),
                 normal_uniforms);

    // bottom left viewport (light)
    glViewport(0, 32, window_size.x / 2, window_size.y / 2 + 32);
    std::vector<gl::Uniform> specular_uniforms;
    specular_uniforms.push_back(gl::UniformTexture(Shader::TEXTURE, lighting_pass[0]));
    this->render(drawable_screen_region,
                 ShaderManager::get_instance()->get_shader("simple_2d.vert", "simple_2d.frag"),
                 specular_uniforms);

    // bottom right viewport (final result)
    glViewport(window_size.x / 2, 32, window_size.x / 2, window_size.y / 2 + 32);

    // create final uniforms out of generated textures
    std::vector<gl::Uniform> final_uniforms = {
        gl::UniformTexture(Shader::TEXTURE, geometry_pass[0]),
        gl::UniformTexture(Shader::EMISSIVE_TEXTURE, lighting_pass[1]),
        gl::UniformTexture(Shader::SPECULAR_TEXTURE, lighting_pass[0])
    };

    // final pass
    this->render(drawable_screen_region,
                 ShaderManager::get_instance()->get_shader("mrt_final_pass.vert", "mrt_final_pass.frag"),
                 final_uniforms);

    // reset the viewport to full window
    glViewport(0, 0, window_size.x, window_size.y);

    // allow the render targets to be reused
    renderer->recycle_render_targets(geometry_pass);
    renderer->recycle_render_targets(lighting_pass);
}

//
void View::render(Element *element) {
    renderer->disable(GL_DEPTH_TEST);
    // set position uniform
    std::vector<gl::Uniform> uniforms;
    Vec2f screen_position = (element->get_position() / window_size) * 2;
    screen_position.y *= -1;
    glm::mat4 mvp = glm::translate(glm::vec3(screen_position.x, screen_position.y, 0));
    uniforms.push_back(gl::UniformMatrix4f(Shader::MVP, false, &mvp));
    uniforms.push_back(gl::UniformTexture(Shader::TEXTURE, element->get_texture()));

    // draw
    renderer->draw(*element,
                   0, 6,
                   ShaderManager::get_instance()->get_shader("2d_default.vert", "2d_default.frag"),
                   uniforms);
}

//
void View::render(Model *model, const Camera * camera) {
    renderer->enable(GL_DEPTH_TEST);
    // add the mvp uniform
    std::vector<gl::Uniform> uniforms;
    glm::mat4 mvp = this->projection * camera->get_view() * model->get_transform();
    uniforms.push_back(gl::UniformMatrix4f(Shader::MVP, false, &mvp));
    // world space uniform
    glm::mat4 world_space = model->get_transform();
    uniforms.push_back(gl::UniformMatrix4f(Shader::WORLD_SPACE, false, &world_space));

    // draw the vertex groupings
    for (VertexGroup &vertex_group : model->get_vertex_groups()) {
        // add the texture
        uniforms.push_back(gl::UniformTexture(Shader::TEXTURE, vertex_group.get_texture()));

        // draw the vertex elements
        renderer->draw(*model,
                       vertex_group,
                       vertex_group.get_shader(),
                       uniforms);

        // remove the texture
        uniforms.pop_back();
    }
}
void View::render(DrawableBox &box, const Camera *camera) {
    // add the mvp uniform
    std::vector<gl::Uniform> uniforms;
    glm::mat4 mvp = this->projection * camera->get_view() * box.get_transform();
    uniforms.push_back(gl::UniformMatrix4f(Shader::MVP, false, &mvp));

    // draw the vertex elements
    renderer->draw(box,
                   0, 36,
                   ShaderManager::get_instance()->get_shader("simple_3d.vert", "simple_3d.frag"),
                   uniforms);
}
//
gl::DataBlock View::get_rectangle_vertex_data(const Rectangle &rectangle) {
    size_t data_size = sizeof (Vec2f) * 6;
    auto data_copier = [this, &rectangle](void *copy_address, size_t data_size) {
        size_t offset = 0;
        const Vec2f &size = rectangle.get_size();

        std::vector<Vec2f> points = {
            Vec2f(0, 0),
            Vec2f(0, size.y),
            Vec2f(size.x, size.y),
            Vec2f(size.x, size.y),
            Vec2f(size.x, 0),
            Vec2f(0, 0),
        };
        for (int i = 0; i < points.size() && offset < data_size; i++) {
            // convert size to screen coordinates (-1, 1)
            Vec2f screen_size = ((points[i] / window_size) * 2) - 1;
            screen_size.y *= -1;
            std::memcpy(copy_address + offset, &screen_size, sizeof (Vec2f));
            offset += sizeof (Vec2f);
        }
    };

    return gl::DataBlock(data_copier, data_size);
}

//
gl::DataBlock View::get_rectangle_uv_data(const Rectangle &rectangle) {
    size_t data_size = sizeof (Vec2f) * 6;
    auto data_copier = [&rectangle](void *copy_address, size_t data_size) {
        static std::vector<Vec2f> uv_points = {
            Vec2f(0, 0),
            Vec2f(0, 1),
            Vec2f(1, 1),
            Vec2f(1, 1),
            Vec2f(1, 0),
            Vec2f(0, 0),
        };

        size_t offset = 0;
        for (int i = 0; i < uv_points.size() && offset != data_size; i++) {
            std::memcpy(copy_address + offset, &uv_points[i], sizeof (Vec2f));
            offset += sizeof (Vec2f);
        }
    };
    return gl::DataBlock(data_copier, data_size);
}
gl::DataBlock View::get_box_vertex_data(const Box &box) {
    size_t data_size = sizeof (Vec3f) * 6 * 6;
    auto data_copier = [this, &box](void *copy_address, size_t data_size) {
        size_t offset = 0;
        std::vector<Vec3f> vertices = box.get_vertices();

        for (int i = 0; i < vertices.size() && offset < data_size; i++) {
            std::memcpy(copy_address + offset, &vertices[i], sizeof (Vec3f));
            offset += sizeof (Vec3f);
        }
    };

    return gl::DataBlock(data_copier, data_size);
}

//
gl::DataBlock View::get_box_uv_data(const Box &box) {
    size_t data_size = sizeof (Vec3f) * 6 * 6;
    auto data_copier = [&box](void *copy_address, size_t data_size) {
        std::vector<Vec2f> uvs = {
            // front
            Vec2f(0.0, 0.0),
            Vec2f(1.0, 0.0),
            Vec2f(1.0, 1.0),
            Vec2f(1.0, 1.0),
            Vec2f(0.0, 1.0),
            Vec2f(0.0, 0.0),
            // top
            Vec2f(0.0, 0.0),
            Vec2f(1.0, 0.0),
            Vec2f(1.0, 1.0),
            Vec2f(1.0, 1.0),
            Vec2f(0.0, 1.0),
            Vec2f(0.0, 0.0),
            // back
            Vec2f(0.0, 0.0),
            Vec2f(1.0, 0.0),
            Vec2f(1.0, 1.0),
            Vec2f(1.0, 1.0),
            Vec2f(0.0, 1.0),
            Vec2f(0.0, 0.0),
            // bottom
            Vec2f(0.0, 0.0),
            Vec2f(1.0, 0.0),
            Vec2f(1.0, 1.0),
            Vec2f(1.0, 1.0),
            Vec2f(0.0, 1.0),
            Vec2f(0.0, 0.0),
            // left
            Vec2f(0.0, 0.0),
            Vec2f(1.0, 0.0),
            Vec2f(1.0, 1.0),
            Vec2f(1.0, 1.0),
            Vec2f(0.0, 1.0),
            Vec2f(0.0, 0.0),
            // right
            Vec2f(0.0, 0.0),
            Vec2f(1.0, 0.0),
            Vec2f(1.0, 1.0),
            Vec2f(1.0, 1.0),
            Vec2f(0.0, 1.0),
            Vec2f(0.0, 0.0),
        };

        size_t offset = 0;
        for (int i = 0; i < uvs.size() && offset != data_size; i++) {
            std::memcpy(copy_address + offset, &uvs[i], sizeof (Vec2f));
            offset += sizeof (Vec2f);
        }
    };
    return gl::DataBlock(data_copier, data_size);
}